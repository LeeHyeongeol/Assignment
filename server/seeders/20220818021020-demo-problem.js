"use strict";

module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.bulkInsert("Problem", [
      {
        id: 1,
        type: "frontend",
        language: "react",
        title: "JSX 문법에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "HTML을 마치 JS처럼 편리하게 사용하기 위한 리액트 JS 확장 문법이다.",
          "빌드 시 Babel에 의해 JS로 변환된다.",
          "변수값은 중괄호로 감싸서 표현한다.",
          "반드시 div/Fragment태그로 감싸진 형태로 쓰지 않아도 된다.",
        ],
        answer: "반드시 div/Fragment태그로 감싸진 형태로 쓰지 않아도 된다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 2,
        type: "frontend",
        language: "react",
        title: "컴포넌트에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "Array 컴포넌트 사용시 map 함수를 사용할 경우 각 컴포넌트는 유일성을 가질 필요가 없다.",
          "함수형 컴포넌트는 생명주기 함수 호출이 불가능하다.",
          "화면에 렌더링 할 DOM 노드들의 정보를 React에게 알려주기 위한 수단",
          "React.createElement() 혹은 JSX 로 작성한다.",
        ],
        answer:
          "Array 컴포넌트 사용시 map 함수를 사용할 경우 각 컴포넌트는 유일성을 가질 필요가 없다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 3,
        type: "frontend",
        language: "react",
        title: "Hook에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "기본 제공 Hook 외에 사용자가 직접 만들어 사용할 수 없다.",
          "사용할땐 반드시 컴포넌트 내부에 선언되어야 한다.",
          "Hook을 통해 함수형 컴포넌트에서도 state와 생명주기관리 로직을 사용할 수 있게 해준다.",
          "state와 생명주기 관리 로직만 따로 작성한 것으로 view와 로직을 분리시켜주는 핵심 역할이다.",
        ],
        answer: "기본 제공 Hook 외에 사용자가 직접 만들어 사용할 수 없다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 4,
        type: "frontend",
        language: "react",
        title: "useState에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "비동기적으로 State를 업데이트한 뒤 리렌더링 요청을 한다",
          "비동기 호출되는 이유는 내부 일관성 유지와 동시 업데이트 활성화 때문이다.",
          "비동기적으로 호출되기 때문에 상태변경 후 즉시 호출하면 업데이트 된다.",
          "useState를 사용하는 이유는 상태변경을 위해서이다.",
        ],
        answer:
          "비동기적으로 호출되기 때문에 상태변경 후 즉시 호출하면 업데이트 된다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 5,
        type: "frontend",
        language: "react",
        title: "Virtual DOM에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "DOM은 브라우저가 화면을 그리기위한 정보를 담고있는 문서 객체이다.",
          "가상의 DOM에서 변경된 내용만 먼저 확인해서 실제 DOM에 업데이트 하여 불필요한 단계를 줄인다.",
          "작성한 component(App.js)를 HTML(document.getElementById('root'))에 밀어넣는다.",
          "브라우저 렌더링 과정에서 DOM Tree는 HTML을 파싱한 내용으로만 만들어진다.",
        ],
        answer:
          "브라우저 렌더링 과정에서 DOM Tree는 HTML을 파싱한 내용으로만 만들어진다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 6,
        type: "frontend",
        language: "vue",
        title: "vue에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "vue.js 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 7,
        type: "frontend",
        language: "vue",
        title: "Single File Component에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "특정 화면 영역의 HTML, CSS, JS 코드를 한 파일에서 관리할 수 있는 방법이다.",
          "싱글 파일 컴포넌트로 개발하려면 Webpack과 같은 번들링 도구가 필요하다. 이는 Vue CLI이다.",
          "vue 확장자를 가진 파일을 모두 싱글 파일 컴포넌트라고 한다.",
          "<template> 태그 안에는 HTML 태그와 뷰 데이터 바인딩 값들을 넣고, <Script> 태그에는 뷰 컴포넌트에서 사용할 속성들을 정의한다.",
        ],
        answer:
          "싱글 파일 컴포넌트로 개발하려면 Webpack과 같은 번들링 도구가 필요하다. 이는 Vue CLI이다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 8,
        type: "frontend",
        language: "vue",
        title: "vue 인스턴스에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "Vue라는 함수로 객체를 생성한다",
          "el은 어떤 HTML 요소에 Vue 객체를 연결할지를 명시한다.",
          "data는 Vue 객체에서 사용할 데이터들을 정의한다. 대부분 'key-value' 형식의 JSON 형태로, 여러 개를 동시에 명시할 수 있다",
          "Vue 객체에서 사용할 함수들을 명시한다. data와 달리 여러 개의 함수를 동시에 명시할 수 없다.",
        ],
        answer:
          "Vue 객체에서 사용할 함수들을 명시한다. data와 달리 여러 개의 함수를 동시에 명시할 수 없다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 9,
        type: "frontend",
        language: "vue",
        title: "vue에서 데이터 변화를 감지하는 방법 중 틀린 것을 고르시오",
        content: [
          "vue에서 data 속성에 있는 값을 사용하고자 할 때, 값이 변화할 때 마다 자동적으로 리렌더링 해주는 인스턴스 속성은 computed와 watch 이다.",
          "computed는 속성 내에 메서드를 정의하고 템플릿내에 호출을 하면 해당 값이 바뀔 때 마다 재호출을 해준다.",
          "computed는 직접 template내에 출력을 해야 해당 메서드가 실행되지만, watch는 값의 변화에만 의존해 메서드를 호출 시킨다.",
          "computed는 캐싱이 되는 성질이 있어 해당 값이 바뀌지 않는다면 계속해서 호출을 한다.",
        ],
        answer:
          "computed는 캐싱이 되는 성질이 있어 해당 값이 바뀌지 않는다면 계속해서 호출을 한다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 10,
        type: "frontend",
        language: "vue",
        title: "vuex에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "State, View, Actions라는 단방향 패턴 흐름으로 데이터들을 관리한다.",
          "vuex는 vue.js에서 컴포넌트들의 상태 관리를 위한 효율적인 라이브러리이다.",
          "vuex를 사용하려면 store 인스턴스를 구성해주어야 하는데 state, getters, mutations, actions 총 4개의 속성으로 구성되어 있다.",
          "mutations 속성은 연산된 state에 접근해 데이터를 조작하는 역할을 한다.",
        ],
        answer:
          "mutations 속성은 연산된 state에 접근해 데이터를 조작하는 역할을 한다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 11,
        type: "frontend",
        language: "angular",
        title: "angular에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "앵귤러 선지 1",
          "앵귤러 선지 2",
          "앵귤러 선지 3",
          "앵귤러 선지 4",
        ],
        answer: "앵귤러 선지 1",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 12,
        type: "frontend",
        language: "angular",
        title: "angular에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "프레임워크인 Angular는 2009년 Google의 직원인 Miskio Heavery의 개인 프로젝트에서 출발하였다.",
          "MVC(Model-View-Controller)제공과 양방향 바인딩 제공으로 전체적인 코드량을 감소시켜 준다.",
          "Directive를 이용한 HTML태그 확장 기능을 제공한다.",
          "모델은 scope객체를 초기화하는 역할로 자바스크립트로 구성된 제어 로직",
        ],
        answer:
          "모델은 scope객체를 초기화하는 역할로 자바스크립트로 구성된 제어 로직",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 13,
        type: "frontend",
        language: "angular",
        title: "Controller에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "scope객체를 초기화하는 역할로 자바스크립트로 구성된 제어 로직이다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "$scope <객체>를 이용하여 모델값을 지정하거나, 함수를 추가할 수 있음",
          "모델을 생성하고 메소드를 가지고 View로 퍼블리싱을 담당하지 않는다",
        ],
        answer:
          "모델을 생성하고 메소드를 가지고 View로 퍼블리싱을 담당하지 않는다",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 14,
        type: "frontend",
        language: "angular",
        title: "angular의 문법에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "vue.js 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다1.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다1.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 15,
        type: "frontend",
        language: "angular",
        title: "angular의 특징에 대해서 틀린 것을 고르시오",
        content: [
          "DOM을 선택/조작하는 코드 작성 불필요",
          "Model은 JSON으로 표현되는 어플리케이션의 특정한 데이터 구조",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다",
          "view는 템플릿과 모델이 합쳐져서 보여지는 화면이다1",
        ],
        answer: "view는 템플릿과 모델이 합쳐져서 보여지는 화면이다1",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 16,
        type: "backend",
        language: "java",
        title: "java에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "java 자체는 백엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다3.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다3.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 17,
        type: "backend",
        language: "java",
        title: "객체지향 핵심 개념에 대한 설명으로 틀린 것은?",
        content: [
          "객체지향을 통해 보다 높은 유지보수성 유지가 가능하다.",
          "모든 데이터를 객체로 취급하므로 객체와 객체 간 자유로운 데이터 이동이 가능하다.",
          "class는 현실 세계의 객체를 컴퓨터 메모리에 생성할 수 있는 템플릿이다.",
          "인스턴스는 컴퓨터 메모리에 존재하는 객체이다.",
        ],
        answer: "인스턴스는 컴퓨터 메모리에 존재하는 객체이다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 18,
        type: "backend",
        language: "java",
        title: "상속에 대한 설명으로 틀린 것은?",
        content: [
          "속성과 메서드가 약간 다른 객체를 필요로 할 때, 기존의 클래스를 이용하여 새로운 클래스를 작성한다.",
          "코드를 간결하게 하여 코드의 재사용성을 높이는 객체지향의 핵심 개념",
          "상속 시 extends 라는 상속 관계 예약어를 사용",
          "단일 상속은 하나의 클래스가 두 개 이상의 상위 클래스를 갖도록 계층구조를 생성",
        ],
        answer:
          "단일 상속은 하나의 클래스가 두 개 이상의 상위 클래스를 갖도록 계층구조를 생성",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 19,
        type: "backend",
        language: "java",
        title: "java 작동원리에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "java 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다5.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다5.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 20,
        type: "backend",
        language: "java",
        title: "java 를 사용하는 이유에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "java 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다6.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다6.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 21,
        type: "backend",
        language: "node",
        title: "node에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "node 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다7.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다7.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 22,
        type: "backend",
        language: "node",
        title: "express에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "node 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다8.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다8.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 23,
        type: "backend",
        language: "node",
        title: "미들웨어에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "node 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다9.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다9.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 24,
        type: "backend",
        language: "node",
        title: "라우터에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "node 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다10.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다10.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 25,
        type: "backend",
        language: "node",
        title: "api에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "node 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다11.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다11.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 26,
        type: "backend",
        language: "python",
        title: "python에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "python 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다12.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다12.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 27,
        type: "backend",
        language: "python",
        title: "파이썬에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "python 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다13.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다13.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 28,
        type: "backend",
        language: "python",
        title: "pycript에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "python 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다14.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다14.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 29,
        type: "backend",
        language: "python",
        title:
          "파이썬과 자바스크립트의 차이에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "python 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 python데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다15.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다15.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 30,
        type: "backend",
        language: "python",
        title: "pyCharm에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "python 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 python 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다16.",
        ],
        answer:
          "동일한 상위 python 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다16.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 31,
        type: "infra",
        language: "aws",
        title: "ec2에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "python 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 python 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다17.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다17.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 32,
        type: "infra",
        language: "aws",
        title: "aws에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "infra 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다18.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다18.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 33,
        type: "infra",
        language: "aws",
        title: "s3에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "infra자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다19.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 직접적인 통신이 가능하다19.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 34,
        type: "infra",
        language: "aws",
        title: "ELB에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "ELB 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 ELB 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 ELB 통신이 가능하다1.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 하위 컴포넌트들 간의 ELB 통신이 가능하다1.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 35,
        type: "infra",
        language: "aws",
        title: "code-deploy에 대한 설명으로 틀린 것을 고르시오",
        content: [
          "code-deploy 자체는 프론트엔드. 즉 View와 관련된 처리들을 관리해주는 프레임워크다.",
          "데이터의 상태에 따라 DOM의 렌더링을 동기화하는 데이터 지향적인 애플리케이션을 설계한다.",
          "데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API 를 지원하는데에 궁극적인 목적이 있다.",
          "동일한 상위 컴포넌트를 가진 code-deploy 간의 직접적인 통신이 가능하다.",
        ],
        answer:
          "동일한 상위 컴포넌트를 가진 code-deploy 간의 직접적인 통신이 가능하다.",
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ]);
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete("Problem", null, {});
  },
};
